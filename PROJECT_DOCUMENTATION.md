# CatchMind Online: 프로젝트 기술 문서

## 1. 프로젝트 개요

- **프로젝트명:** CatchMind Online (가칭)
- **목표:** 친구들과 함께 즐길 수 있는 실시간 멀티플레이어 그림 맞추기 웹 게임입니다.
- **주요 기능:**
  - 여러 사용자가 같은 방(Room)에 참여합니다.
  - 한 명의 출제자가 주어진 제시어를 그림으로 설명합니다.
  - 나머지 참여자들은 그림을 보고 실시간으로 정답을 맞힙니다.
  - 정답을 맞히면 다음 라운드로 넘어가며, 출제자가 변경됩니다.

---

## 2. 프로젝트 구조

프로젝트는 NestJS 백엔드와 테스트용 HTML 클라이언트로 구성되어 있습니다.

```
BE_whirix/
├── src/                      # NestJS 백엔드 소스 코드
│   ├── game/                 # 게임 핵심 로직 모듈
│   │   ├── game.gateway.ts   # 웹소켓(Socket.IO) 이벤트 처리 및 통신
│   │   ├── game.service.ts   # 게임 상태 관리 (방, 플레이어, 정답 등)
│   │   └── dto/              # 클라이언트 데이터 검증용 DTO
│   ├── app.module.ts         # 메인 앱 모듈
│   └── main.ts               # 애플리케이션 시작점
├── test/                     # 테스트 관련 파일
│   └── test.html             # 게임 테스트를 위한 웹 클라이언트
├── GEMINI.md                 # AI 개발 지원을 위한 프로젝트 요약
├── PROJECT_DOCUMENTATION.md  # 현재 보고 있는 프로젝트 기술 문서
└── ... (package.json, tsconfig.json 등 설정 파일)
```

- **`src/game/` 디렉토리:** 게임의 핵심 기능이 모두 이 안에 구현되어 있습니다.
  - **`game.gateway.ts`:** 클라이언트와의 모든 실시간 통신(이벤트 수신 및 전송)을 담당합니다. 일종의 '관제탑' 역할을 합니다.
  - **`game.service.ts`:** 실제 게임의 상태와 데이터를 관리합니다. 방 생성, 플레이어 추가/제거, 문제 단어 선정, 정답 확인 등 순수한 게임 로직을 처리하는 '두뇌' 역할을 합니다.
- **`test/test.html`:** 서버의 기능을 브라우저에서 직접 테스트하기 위한 간단한 클라이언트입니다. 여러 탭을 열어 다수의 사용자가 접속한 상황을 시뮬레이션할 수 있습니다.

---

## 3. 핵심 로직 동작 원리 (게임 루프)

게임은 클라이언트와 서버가 특정 이벤트를 주고받으며 진행됩니다. 전체 흐름은 다음과 같습니다.

**1. 플레이어 참가 (`joinGame` 이벤트)**
   - 사용자가 `test.html`에 접속하면, 클라이언트는 `joinGame` 이벤트를 서버로 보냅니다.
   - `GameGateway`가 이벤트를 받아 `GameService`를 통해 플레이어를 특정 방(Room)에 추가합니다.
   - **첫 플레이어의 경우:** 방의 첫 번째 플레이어는 자동으로 **출제자(`roundOwner`)**가 되며, `GameService`는 미리 준비된 단어 목록에서 무작위로 **문제 단어(`currentWord`)**를 하나 선택해 방에 설정합니다.
   - 서버는 방에 있는 모든 플레이어에게 새로운 사용자의 참여(`userJoined`)와 현재 출제자가 누구인지(`presenterAssigned`)를 알립니다.
   - **가장 중요한 부분:** 서버는 **오직 출제자에게만** `roundStarted` 이벤트를 보내 문제 단어가 무엇인지 비밀리에 알려줍니다.

**2. 그림 그리기 (`drawing` 이벤트)**
   - 출제자는 문제 단어를 보고 캔버스에 그림을 그리기 시작합니다.
   - 그림을 그리는 동안, 클라이언트는 마우스 좌표를 담아 `drawing` 이벤트를 계속해서 서버로 보냅니다.
   - `GameGateway`는 이벤트를 보낸 사람이 현재 출제자가 맞는지 확인합니다. 출제자가 아니면 이 요청을 무시합니다.
   - 출제자가 맞다면, 그림 좌표 데이터를 `GameService`에 저장하고, 방에 있는 다른 모든 참여자에게 `drawing:remote` 이벤트를 보내 그림이 실시간으로 그려지도록 합니다.

**3. 정답 추측 (`submitGuess` 이벤트)**
   - 참여자들은 출제자가 그리는 그림을 보고 정답을 추측하여 입력창에 입력 후 '제출'합니다.
   - 클라이언트는 `submitGuess` 이벤트를 서버로 보냅니다.
   - `GameGateway`는 `GameService`의 `checkGuess` 메소드를 호출하여 제출된 단어가 현재 문제 단어와 일치하는지 확인합니다.
   - 서버는 정답 여부와 관계없이, 추측 결과(`guessResult`)를 방의 모든 사람에게 방송하여 누가 어떤 답을 제출했는지 알려줍니다.

**4. 라운드 종료 및 다음 라운드 시작**
   - 만약 정답자가 나오면(`res.correct === true`):
     1. 서버는 정답자의 이름과 함께 `roundEnded` 이벤트를 방 전체에 방송합니다.
     2. 약 3초의 지연 후, `GameGateway`는 `GameService`의 `startNextRound` 메소드를 호출합니다.
     3. `startNextRound` 메소드는 다음 출제자(순서상 다음 사람)를 지정하고, 새로운 문제 단어를 할당하며, 이전 라운드의 그림 데이터를 모두 삭제합니다.
     4. 서버는 모든 클라이언트에게 `newRoundStarting` 이벤트를 보내 캔버스를 지우고 새 라운드를 준비하라고 알립니다.
     5. 마지막으로, 새로운 출제자 정보(`presenterAssigned`)와 새로운 문제 단어(`roundStarted`, 새 출제자에게만)를 보내며 **1번 과정부터 새로운 게임 루프를 시작합니다.**

---

## 4. 개발 프로세스

이 프로젝트는 다음과 같은 단계별, 반복적 개발 프로세스를 통해 구현되었습니다.

1.  **기본 환경 설정:** NestJS 프로젝트를 초기화하고 Socket.IO 통신을 위한 기본 설정을 완료했습니다.
2.  **실시간 그림 동기화:** `test.html` 클라이언트를 만들고, 한쪽에서 그린 그림이 다른 쪽에 실시간으로 보이는 기능을 우선 구현했습니다. (`drawing`, `drawing:remote` 이벤트 구조 확립)
3.  **역할 구분 도입:** '출제자'와 '참여자' 역할을 `GameService`에 추가하고, 출제자만 그림을 그릴 수 있도록 `GameGateway`에서 권한을 확인하는 로직을 구현했습니다.
4.  **문제 출제 및 정답 확인:** 목(Mock) 데이터로 문제 단어 목록을 만들고, 출제자에게만 단어를 보여주는 기능, 참여자가 정답을 제출하고 서버가 정답을 확인하는 기능을 구현했습니다.
5.  **게임 루프 완성:** 정답을 맞혔을 때 다음 라운드로 넘어가고, 출제자 역할을 다음 사람에게 넘겨주는 순환 로직을 구현하여 완전한 게임의 흐름을 만들었습니다.

각 단계마다 `test.html`을 통해 기능이 의도대로 동작하는지 즉시 확인하며 개발을 진행했습니다.
